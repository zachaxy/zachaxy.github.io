<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zachaxy">





<title>RxJava源码详解-线程切换原理 | Hexo</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Zachaxy&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Zachaxy&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">RxJava源码详解-线程切换原理</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zachaxy&nbsp;&#124;&nbsp;</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 3, 2017&nbsp;&nbsp;9:43:49&nbsp;&#124;&nbsp;</a>
                        </span>
                    

                    
                        <span class="post-count">
                        Words: <a href="#">13k&nbsp;&#124;&nbsp;</a>
                        </span>
                    

                    
                        <span class="post-readtime">
                        About: <a href="#">12 mins.</a>
                        </span>
                    

                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="线程调度深入"><a href="#线程调度深入" class="headerlink" title="线程调度深入"></a>线程调度深入</h1><p>一个基本线程调度的例子:事件在IO线程产生,然后再UI线程被消费;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> <span class="title class_">Observable</span>.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> String&gt; subscriber)</span> &#123;</span><br><span class="line">        subscriber.onNext(<span class="string">&quot;Hello RxJava!&quot;</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="subscribeOn-原理"><a href="#subscribeOn-原理" class="headerlink" title="subscribeOn()原理"></a>subscribeOn()原理</h2><p><code>subscribeOn()</code>用来指定<code>Observable</code>在哪个线程中执行事件流，也就是指定<code>Observable</code>中<code>OnSubscribe</code>(计划表)的<code>call()</code>方法在那个线程发射数据。下面通过源码分析<code>subscribeOn()</code>是怎样实现线程的切换的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title function_">subscribeOn</span><span class="params">(Scheduler scheduler)</span> &#123;</span><br><span class="line">    <span class="comment">//忽略这个 if 分支吧</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="built_in">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重点看这个:this指的是调用线程切换方法subscribeOn()的Observerble ,</span></span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> <span class="title class_">OperatorSubscribeOn</span>&lt;T&gt;(<span class="built_in">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>subscribeOn()方法是 Observerble 中的方法,一旦调用了该方法,就会创建出一个新的 Observerble 对象;当然还是通过create(OnSubscribe)方法来创建Observerble ;</p>
<p>再来看一下新创建的这个Observerble 对象中的OnSubscribe的实现类内部是如何实现的;OperatorSubscribeOn是OnSubscribe的实现类,自然也要实现call方法来触发事件了.同时一旦换了新的Observerble ,那么最终的观察者订阅的自然也就是新的Observerble 了,这一点一定要明确;那么自然call方法中的参数也就持有了原始观察者的引用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OperatorSubscribeOn</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Observable</span>.OnSubscribe&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;   <span class="comment">//调度器</span></span><br><span class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;  <span class="comment">//原始Observable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数,传入原始的被观察者和线程调度器;</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scheduler = scheduler;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)原始观察者订阅了新的Observable后,将先执行此call方法(还记得订阅函数是如何实现的吗?)</span></span><br><span class="line">  <span class="comment">//这个参数的final的,其实是为了给内部类调用,内部类已经在其他线程了;</span></span><br><span class="line">  <span class="comment">//传入的参数是原始观察者;和上一篇操作符的原理类似,也是在call方法中创建了一个代理观察者,使其与原始被观察者订阅</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="built_in">super</span> T&gt; subscriber)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Scheduler.<span class="type">Worker</span> <span class="variable">inner</span> <span class="operator">=</span> scheduler.createWorker();  <span class="comment">//创建了一个worker对象,内部持有一个线程池</span></span><br><span class="line">        subscriber.add(inner);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)call方法中使用传入的调度器创建的Worker对象的schedule方法切换线程,传入的Action0会作为一个参数传入runnable中</span></span><br><span class="line">        <span class="comment">//runnable的run方法中会调用action0的call方法,然后runnable又被添加到线程池中被执行;</span></span><br><span class="line">          inner.schedule(<span class="keyword">new</span> <span class="title class_">Action0</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">          <span class="comment">//(3)根据外层call中传来的原始观察者,创建了一个新的观察者(代理观察者),而且代理观察者持有原始观察者的引用</span></span><br><span class="line">                    Subscriber&lt;T&gt; s = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;T&gt;(subscriber) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123;</span><br><span class="line">                        <span class="comment">//(5) 新的(代理)观察者收到数据后直接发送给原始观察者</span></span><br><span class="line">                        subscriber.onNext(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">//(4)在切换的线程中，新的观察者订阅原始Observable，用来接收数据</span></span><br><span class="line">              <span class="comment">//代理观察者能收到数据的前提是因为代理观察者订阅了原始被观察者;</span></span><br><span class="line">              <span class="comment">//其实这个订阅的动作是在新线程中执行的.</span></span><br><span class="line">                source.unsafeSubscribe(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>call</code>方法中通过<code>scheduler.createWorker().schedule(Action0)</code>完成线程的切换.</p>
<p>简单说:这里在subscribeOn()方法中新创建了一个Observable对象(代理Observable),于是发生了原始观察者与代理被观察者订阅的情况,于是代理被观察者中的call()方法被先执行,但是代理被观察者哪里有数据呢,还不是用老方法,又创建了一个代理观察者,然后让代理观察者与原始被观察者进行订阅,一旦发生订阅,数据就发出来了,数据发出来给了代理观察者,代理观察者的onNext()方法中有调用了原始观察者的onNext()方法;这不就解决了嘛,可是如何实现的线程切换呢?</p>
<p>提前说一下:这个Action0对象时作为参数传入一个Runnable实例中,然后将该runnable对象传入线程池,这样就实现了线程的切换,也就是说这个Action0()中的所有动作都是在新的线程池中执行的;</p>
<p>上述说说的一切动作都是在scheduler.createWorker().schedule(new Action0(XXX));都是在这个Action0()中发生的.</p>
<p>这里涉及到两个对象:<code>Scheduler</code>和<code>Worker</code>,究竟这是怎么实现的线程切换呢?</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>其实在subscribeOn(Scheduler  scheduler)方法中传入的参数就是 Scheduler 对象;</p>
<p>由于RxJava中有多种调度器，我们就看一个简单的<code>Schedulers.newThread()</code>，其他调度器的思路是一样的.</p>
<p>先看一下<code>Schedulers</code>这个类,<code>Schedulers</code>就是一个调度器的管理器,大管家;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Schedulers</span> &#123;</span><br><span class="line">    <span class="comment">//各种调度器对象,看着眼熟吧.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler computationScheduler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler ioScheduler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler newThreadScheduler;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//单例，Schedulers被加载的时候，上面的各种调度器对象已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Schedulers</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Schedulers</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造方法,在构造方法中初始化各种调度器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Schedulers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RxJavaSchedulersHook</span> <span class="variable">hook</span> <span class="operator">=</span> RxJavaPlugins.getInstance().getSchedulersHook();</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//这里只关注创建一个新的线程的调度器</span></span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">nt</span> <span class="operator">=</span> hook.getNewThreadScheduler();</span><br><span class="line">        <span class="keyword">if</span> (nt != <span class="literal">null</span>) &#123;</span><br><span class="line">            newThreadScheduler = nt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//①.创建newThreadScheduler对象</span></span><br><span class="line">            newThreadScheduler = RxJavaSchedulersHook.createNewThreadScheduler();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//下面其余的线程不管.......................................</span></span><br><span class="line">    <span class="comment">//下面是Compute线程的创建  </span></span><br><span class="line">      <span class="type">Scheduler</span> <span class="variable">c</span> <span class="operator">=</span> hook.getComputationScheduler();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">            computationScheduler = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            computationScheduler = RxJavaSchedulersHook.createComputationScheduler();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//下面是IO线程的创建;</span></span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">io</span> <span class="operator">=</span> hook.getIOScheduler();</span><br><span class="line">        <span class="keyword">if</span> (io != <span class="literal">null</span>) &#123;</span><br><span class="line">            ioScheduler = io;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ioScheduler = RxJavaSchedulersHook.createIoScheduler();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//②. 获取NewThreadScheduler对象,也就是我们在使用调度调用的该方法来获取一个新线程的调度器;</span></span><br><span class="line">  <span class="comment">//我们平时使用线程切换时,就是调用的 Schedulers.io(),Schedulers.newThread()等方法来获取一个Scheduler对象的!!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title function_">newThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE.newThreadScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着跟踪<code>RxJavaSchedulersHook.createNewScheduler()</code>，看看<code>newThreadScheduler</code>究竟是如何创建的?</p>
<p>我们发现无论是IO线程,Compute线程,还是NewThread线程调度器,都是<code>RxJavaSchedulersHook.createXXX()</code>方法创建出来了,其内部是用工厂方法实现的.</p>
<p>最终会找到一个叫<code>NewThreadScheduler</code>的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NewThreadScheduler</span> <span class="keyword">extends</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NewThreadScheduler</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Worker <span class="title function_">createWorker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NewThreadWorker</span>(threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终看到<code>NewThreadScheduler</code>就是我们调用<code>subscribeOn(Schedulers.newThread() )</code>传入的调度器对象，通过上面的分析,我们已经明白了<code> Scheduler</code> 的产生原理</p>
<p><strong>产生<code>Scheduler</code> 并不是最终目的,而是通过<code>Scheduler</code> 产生 <code>Worker</code>,然后调用<code>Worker.schedule(Action0)</code>实现线程的切换.</strong></p>
<h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>通过上面的分析,我们已经明白了<code> Scheduler</code> 的产生原理,产生<code>Scheduler</code> 并不是最终目的,而是通过<code>Scheduler</code> 产生 <code>Worker</code>,然后调用<code>Worker.schedule(Action0)</code>实现线程的切换.</p>
<p>每个调度器对象都有一个<code>createWorker</code>方法用于创建一个<code>Worker</code>对象，而<code>NewThreadScheduler</code>对应创建的<code>Worker</code>是一个叫<code>NewThreadWorker</code>的对象.</p>
<p>而在上面的分析中我们也看到了, <code>OperatorSubscribeOn</code>类中调用了</p>
<p><code>final Scheduler.Worker inner = scheduler.createWorker()</code>方法来得到一个 Worker,然后又调用 <code>inner.schedule(Action0)</code>实现线程的切换</p>
<p>接下来我们跟进<code>schedule()</code>方法查看其内部的实现原理.同样,这里的<code> Worker</code> 依然是以最简单的<code>NewThreadWorker</code> 为例.这里删减了部分代码,只留取对整体结构有用的部分.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThreadWorker</span> <span class="keyword">extends</span> <span class="title class_">Scheduler</span>.Worker <span class="keyword">implements</span> <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor;   <span class="comment">//线程池,在下面构造函数中进行初始化.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NewThreadWorker</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>, threadFactory);</span><br><span class="line">        executor = exec;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//默认调用的是这个方法;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Subscription <span class="title function_">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> schedule(action, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Subscription <span class="title function_">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="type">long</span> delayTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scheduleActual(action, delayTime, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重要：其实 worker.schedule()最终调用的是这个方法</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledAction <span class="title function_">scheduleActual</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="type">long</span> delayTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">//别紧张,源码中直接将传入的 action return回来了... 这一步相对于什么也没做;</span></span><br><span class="line">        <span class="type">Action0</span> <span class="variable">decoratedAction</span> <span class="operator">=</span> schedulersHook.onSchedule(action);</span><br><span class="line">        <span class="comment">//ScheduledAction就是一个Runnable对象，在run()方法中调用了Action0.call()</span></span><br><span class="line">        <span class="type">ScheduledAction</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledAction</span>(decoratedAction);</span><br><span class="line">        Future&lt;?&gt; f;</span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            f = executor.submit(run);   <span class="comment">//将Runnable对象放入线程池中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = executor.schedule(run, delayTime, unit);  <span class="comment">//延迟执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        run.add(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> run;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>OperatorSubscribeOn</code>计划表中通过<code>NewThreadWorker.schedule(Action0)</code>，将<code>Action0</code>作为参数传入一个<code>Runnable</code>的实现类:<code>ScheduledAction</code>,然后将这个runnable放入到一个线程池中执行，这样就实现了线程的切换。</p>
<p>简单说:最原始的<code>subscribeOn()</code>—调用了—-<code>create(new OperatorSubscribeOn&lt;T&gt;(this, scheduler))</code>—-创建一个代理被观察者—-&gt;<code>OperatorSubscribeOn()</code>中实现了<code>call()</code>方法—-&gt;call()方法中调用了<code>NewThreadWorker.schedule(Action0)</code>—-<code>Action0</code>被包装称一个<code>RUnnable</code>对象,然后<code>schedule()</code>方法内部使用了线程池,创建一个新的线程,并将包装的<code>Runnable</code>对象传递进去,这样就实现了线程的切换</p>
<p>步骤:</p>
<ol>
<li>原始被观察者调用subscribeOn()方法准备切换线程,(这时候还没切换呢.)产生一个代理被观察者</li>
<li>原始订阅者订阅代理被观察者(明面代码上你能看得到的)</li>
<li>代理被观察者的<code>onSubscribe.call()</code>方法执行,提供了一个<code>Runnable</code>对象,也就是线程已经被切换了</li>
<li><strong>新线程</strong>中产生一个新的代理观察者,代理观察者订阅原始被观察者(接下来的动作也都是在新线程中执行)</li>
<li>原始被观察者发射数据,这个动作已经是在新线程中执行了</li>
<li>代理观察者收到数据,再将数据转发给原始观察者</li>
</ol>
<p>看这张图,帮助理解<br><img src="http://note.youdao.com/yws/public/resource/3a378f8ba029c8148bde85d73d9704c7/xmlnote/1853E77FF7BA42C5ABBAA8B9671EB41B/70" alt="image"></p>
<blockquote>
<p>此处用到了多线程的知识,多线程这一块还需要总结整理;</p>
</blockquote>
<h3 id="多次subscribeOn-的情况"><a href="#多次subscribeOn-的情况" class="headerlink" title="多次subscribeOn()的情况"></a>多次subscribeOn()的情况</h3><p>我们发现，每次使用<code>subscribeOn</code>都会产生一个新的<code>Observable</code>，并产生一个新的计划表<code>OnSubscribe</code>，目标Subscriber最后订阅的将是最后一次<code>subscribeOn</code>产生的新的<code>Observable</code>。在每个新的<code>OnSubscribe</code>的<code>call</code>方法中都会有一个产生一个新的线程，在这个新线程中订阅上一级<code>Observable</code>，并创建一个新的<code>Subscriber</code>接受数据，最终原始<code>Observable</code>将在第一个新线程中发射数据，然后传送给给下一个新的观察者，直到传送到目标观察者，所以多次调用<code>subscribeOn</code>只有第一个起作用（这只是表面现象，其实每个<code>subscribeOn</code>都切换了线程，只是最终目标<code>Observable</code>是在第一个<code>subscribeOn</code>产生的线程中发射数据的）</p>
<p>也就是说多次调用<code>subscribeOn()</code>方法其实不是只有第一次方法其作用,而是每次都起作用,这里说的第一次起作用其实说的是最原始的数据发射是在第一次subscribeOn()指定的线程,只不过我们很少关注中间数据的处理过程而已;</p>
<p>一张图理解多订阅的过程:</p>
<p><img src="http://note.youdao.com/yws/public/resource/3a378f8ba029c8148bde85d73d9704c7/xmlnote/2AF59C14A4AC422F83E220C8C14059A8/68" alt="image"></p>
<p>下面是多次线程切换的伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第3个subscribeOn产生的新线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Subscriber</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subscriber</span>();</span><br><span class="line">        <span class="comment">//第2个subscribeOn产生的新线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">Subscriber</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subscriber</span>();</span><br><span class="line">                <span class="comment">//第1个subscribeOn产生的新线程</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        Subscriber&lt;T&gt; s3 = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;T&gt;(subscriber) &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123;</span><br><span class="line">                                subscriber.onNext(t);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="comment">//①. 最后一个新观察者订阅原始Observable</span></span><br><span class="line">                        Observable.subscribe(s3);</span><br><span class="line">                        <span class="comment">//②. 原始Observable将在此线程中发射数据</span></span><br><span class="line"></span><br><span class="line">                              <span class="comment">//③. 最后一个新的观察者s3接受数据</span></span><br><span class="line"></span><br><span class="line">                              <span class="comment">//④. s3收到数据后，直接发送给s2，s2收到数据后传给s1,...最后目标观察者收到数据</span></span><br><span class="line">                         &#125; </span><br><span class="line">                &#125;.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>


<h1 id="observeOn原理"><a href="#observeOn原理" class="headerlink" title="observeOn原理"></a>observeOn原理</h1><blockquote>
<p>还是需要进一步的整理</p>
</blockquote>
<p>observeOn调用的是lift操作符。lift操作符创建了一个代理的Observable，用于接收原始Observable发射的数据，然后在Operator中对数据做一些处理后传递给目标Subscriber。observeOn一样创建了一个代理的Observable，并创建一个代理观察者接受上一级Observable的数据，代理观察者收到数据之后会开启一个线程，在新的线程中，调用下一级观察者的onNext、onCompete、onError方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title function_">observeOn</span><span class="params">(Scheduler scheduler)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, RxRingBuffer.SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title function_">observeOn</span><span class="params">(Scheduler scheduler, <span class="type">int</span> bufferSize)</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> observeOn(scheduler, <span class="literal">false</span>, bufferSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title function_">observeOn</span><span class="params">(Scheduler scheduler, <span class="type">boolean</span> delayError, <span class="type">int</span> bufferSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="built_in">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> <span class="title class_">OperatorObserveOn</span>&lt;T&gt;(scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到使用observeOn(Scheduler scheduler)方法时,也是传入了一个scheduler,这和subscribeOn()方法如出一辙,,随着不断深入的调用,其最终使用 lift()操作符创建了一个Observable 对象.这里先不管lift,接着上面的lift()中创建了一个OperatorObserveOn类,其源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OperatorObserveOn</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Observable</span>.Operator&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="comment">//创建代理观察者，用于接收上一级Observable发射的数据,而这个child就是原始观察者.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="built_in">super</span> T&gt; call(Subscriber&lt;? <span class="built_in">super</span> T&gt; child) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> ImmediateScheduler) &#123;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> <span class="title class_">ObserveOnSubscriber</span>&lt;T&gt;(scheduler, child, delayError, bufferSize);</span><br><span class="line">            parent.init();</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//-----------------------------------我是分割线-------------------------------------------------------- </span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  先不管前面的复杂逻辑了,总之现在有了代理被观察者和代理观察者,像map那样发生了订阅,然后原始被观察者开始发数据了</span></span><br><span class="line"><span class="comment">  在代理观察者中,自然也有onNext,onCompleted(),onError()方法,但是在这三个方法后都调用了 schedule()函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="comment">//代理观察者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ObserveOnSubscriber</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Subscriber</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Action0</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="built_in">super</span> T&gt; child;</span><br><span class="line">        <span class="keyword">final</span> Scheduler.Worker recursiveScheduler;</span><br><span class="line">        <span class="keyword">final</span> NotificationLite&lt;T&gt; on;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Object&gt; queue;</span><br><span class="line">        <span class="comment">//接受上一级Observable发射的数据</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isUnsubscribed() || finished) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!queue.offer(on.next(t))) &#123;</span><br><span class="line">                onError(<span class="keyword">new</span> <span class="title class_">MissingBackpressureException</span>());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//在代理观察者中,自然也有onNext,onCompleted(),onError()方法,但是在这三个方法后都调用了 schedule()函数</span></span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="keyword">final</span> Throwable e)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启新线程处理数据,切换线程就是在这里,重要的方法.</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">                recursiveScheduler.schedule(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// only execute this from schedule()</span></span><br><span class="line">        <span class="comment">//在新线程中将数据发送给目标观察者,注意这里是观察者,其call方法是因为实现了Action0接口,什么时候调用呢?</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">missed</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentEmission</span> <span class="operator">=</span> emitted;</span><br><span class="line">            <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="built_in">this</span>.queue;</span><br><span class="line">            <span class="keyword">final</span> Subscriber&lt;? <span class="built_in">super</span> T&gt; localChild = <span class="built_in">this</span>.child;</span><br><span class="line">            <span class="keyword">final</span> NotificationLite&lt;T&gt; localOn = <span class="built_in">this</span>.on;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    localChild.onNext(localOn.getValue(v));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得<code>subscribeOn()</code>时传入的<code>Scheduler</code>吗,这个<code>observeOn()</code>也传入了一个<code>Scheduler</code>,和之前一样,通过这个<code>scheduler产生一个Worker</code>,然后调用<code>Worker.schedule(Action0)</code>实现线程的切换.与<code>subscribeOn()</code>不同的是,这个线程切换时在代理观察者执行<code>onNext()</code>中执行的,也就是说先把线程切换过去,然后代理观察者在执行的 <code>actual.onNext()</code>方法.</p>
<p>我们可以参照多次subscribeOn()的图解示例,可以把第二次subscribeOn()替换成observeOn(),那么在产生的第二个代理观察者给原始观察者发消息时,本来是在其onNext()方法中直接调用原始观察者的onNext()的,但是由于有observeOn(),所以在执行onNext的时候进行了线程切换,然后在调用原始观察者的onNext()</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只要涉及到操作符，其实就是生成了一套代理的<code>Subscriber</code>(观察者)、<code>Observable</code>(被观察者)和<code>OnSubscribe</code>(计划表)。<code>Observable</code>最典型的特征就是链式调用，我们暂且将每一步操作称为一级。代理的<code>OnSubscribe</code>中的<code>call</code>方法就是让代理<code>Subscriber</code>订阅上一级<code>Observable</code>，直到订阅到原始<code>Observable</code>发射数据，代理<code>Subscriber</code>收到数据后，可能对数据做一些操作也有可能切换线程，然后将数据传送给下一级<code>Subscriber</code>，直到目标观察者接收到数据，目标观察者在那个线程接受数据取决于上一个<code>Subscriber</code>在哪一个线程调用目标观察者的方法。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>本文作者:</span>
                        <span>Zachaxy</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>版权声明:</span>
                        <span>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/"># 框架设计之美</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2017/04/10/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/">深度优先算法</a>
            
            
            <a class="next" rel="next" href="/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8E%9F%E7%90%86/">RxJava源码详解-操作符原理</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zachaxy | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>