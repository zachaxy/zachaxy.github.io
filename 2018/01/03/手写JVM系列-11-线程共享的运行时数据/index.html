<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zachaxy">





<title>手写JVM系列(11)-线程共享的运行时数据 | Hexo</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Zachaxy&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Zachaxy&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">手写JVM系列(11)-线程共享的运行时数据</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zachaxy&nbsp;&#124;&nbsp;</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 3, 2018&nbsp;&nbsp;16:42:03&nbsp;&#124;&nbsp;</a>
                        </span>
                    

                    
                        <span class="post-count">
                        Words: <a href="#">6.8k&nbsp;&#124;&nbsp;</a>
                        </span>
                    

                    
                        <span class="post-readtime">
                        About: <a href="#">6 mins.</a>
                        </span>
                    

                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p>前面已经初步实现了线程私有的运行时数据区，主要包括操作数栈和局部变量表。接下来将继续丰富运行时数据区的内容——线程共享的运行时数据区，包括方法区和运行时常量池。本节的代码集中在 <a target="_blank" rel="noopener" href="https://github.com/zachaxy/JVM/tree/master/Java/src/runtimedata/heap">heap</a> 包下。同时也会对一些概念做出解释。因为自己之前在这些概念上的错误认识，走了很多弯路。</p>
</blockquote>
<span id="more"></span>

<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>之前我们已经可以找到 class 文件，并把其内容加载到内存中，对其解析成一个 ClassFile 的结构，但是 ClassFile 中的内容仍然无法直接在方法区使用，还需要进一步的转换。其实转换的内容不多，我们通过代码来直观的对已一下 ClassFile 和 Zclass 中的区别。(为避免和 JDK 中已有的类名冲突，这里将我们自定义的 <code>class</code>，<code>method</code>，<code>field</code> 等前面都加一个 <code>z</code> 以作区分。)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zclass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> accessFlags;        <span class="comment">// 表示当前类的访问标志</span></span><br><span class="line">    <span class="keyword">public</span> String thisClassName;   <span class="comment">//当前类名字(完全限定名)</span></span><br><span class="line">    <span class="keyword">public</span> String superClassName;  <span class="comment">//父类名字(完全限定名)</span></span><br><span class="line">    <span class="keyword">public</span> String[] interfaceNames;<span class="comment">//接口名字(完全限定名,不可以为null,若为实现接口,数组大小为0)</span></span><br><span class="line">    <span class="keyword">private</span> RuntimeConstantPool runtimeConstantPool;<span class="comment">//运行时常量池,注意和class文件中常量池区别;</span></span><br><span class="line">    Zfield[] fileds;        <span class="comment">//字段表,包括静态和非静态，此时并不分配 slotId；下面的staticVars 是其子集</span></span><br><span class="line">    Zmethod[] methods;      <span class="comment">//方法表，包括静态和非静态</span></span><br><span class="line">    ZclassLoader loader;    <span class="comment">//类加载器</span></span><br><span class="line">    Zclass superClass;      <span class="comment">//当前类的父类class,由类加载时,给父类赋值;</span></span><br><span class="line">    Zclass[] interfaces;    <span class="comment">//当前类的接口class,由类加载时,给父类赋值;</span></span><br><span class="line">    <span class="type">int</span> instanceSlotCount;  <span class="comment">//非静态变量占用slot大小,这里只是统计个数(从顶级父类Object开始算起)</span></span><br><span class="line">    <span class="type">int</span> staticSlotCount;    <span class="comment">// 静态变量所占空间大小</span></span><br><span class="line">    Slots staticVars;      <span class="comment">// 存放静态变量</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minorVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> majorVersion;</span><br><span class="line">    <span class="keyword">public</span> ConstantPool constantPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> accessFlags;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> thisClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> superClass;         <span class="comment">//同 thisClass 的索引值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] interfaces;     <span class="comment">//存放所实现的接口在常量池中的索引。同 thisClass 的索引值。</span></span><br><span class="line">    <span class="keyword">private</span> MemberInfo[] fields;    <span class="comment">//存放类中所有的字段，包括静态的非静态的；不同的属性通过字段的访问修饰符来读取；</span></span><br><span class="line">    <span class="keyword">private</span> MemberInfo[] methods;   <span class="comment">//存放类中所有的方法，包括静态的非静态的；不同的属性通过方法的访问修饰符来读取；</span></span><br><span class="line">    <span class="keyword">private</span> AttributeInfo[] attributes; <span class="comment">//属性表，存放类的属性；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比由 ClassFile -&gt; Zclass 的转换可以发现：eg：ClassFile 中  superClass 的值是一个 int 的索引值，其指向常量池的一个常量，该常量由通过一个索引指向常量池中的 utf8-constant，从而用来表示当前 class 的父类的名字(字符串)。而在 Zclass 中，可以看到有一个 superClass 的成员变量，其类型为 Zclass 类型，而不再是简单的字符串。再来看在类中定义的成员变量，在 ClassFile 中成员变量是保存在MemberInfo 中，这也是简单的字符描述(变量类型，变量名字),在 Zclass 中保存的是新定义的 Zfield 类型的变量，这些都是需要转换的地方。</p>
<p>所以转换的本质是什么：<br>** class 文件中全是字符串，而现在加载到内存中了，就不能简单的用一个字符串来描述了，而是一个指向内存的一个实体**</p>
<p>所以针对于 ClassFile 到 Zclass 的转换，具体要转换的有三部分：</p>
<ul>
<li>类信息本身，这里定义为 Zclass</li>
<li>字段信息，这里定义为 Zfield，表示在类中定义的变量(静态+非静态)，Zfield 中有一个成员变量 Zclass，表明当前字段属于哪个类</li>
<li>方法信息，这里定义为 Zmethod，表示在类中定义的方法(静态+非静态)，Zmethod 中有一个成员变量 Zclass，表明当前方法属于哪个类</li>
</ul>
<p>而转换为 Zclass 的类，就是放在方法区的，其实叫方法区是有干扰的，让人以为方法区只是存放类中的方法的，并不是这样的。方法区存放的是一个 class 文件的描述，包括该类的权限，该类实现了哪些接口，该类的父类是谁，该类有哪些字段，以及字段的权限，该类有哪些方法，以及方法的权限等。<br>在本 JVM 中，方法区的实现是使用了一个 HashMap，其中 key 的 class 的全限定名，value 为加载进来的 zclass 对象。</p>
<p>读完上面的描述，你可能还是一头雾水，暂时先放到一边，因为单将方法区无法将清楚，其还要配合下面的运行时常量，才能查看其全貌。</p>
<h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><p>常量池，这个概念之前就遇到过，那是在解析 class 文件时，class 文件中就有一个常量池的概念，现在又遇到了常量池，不过不是一回事。</p>
<p>这里再次解释一下 class 文件中的常量池的概念。我们将 java 代码通过 javac 编译为 class 文件，接下来再运行 java 程序的时候就完全不需要 java 文件了，只需要 class 文件即可，但是 class 文件是保存在本地磁盘上的文件，里面全是0101的字节码，或者说是字符串，那各个字符串之间如何产生联系呢？那就是通过常量池，并给常量池安排了序号，每个序号都对应一个常量(字符串)，然后 class 文件规定了一个格式，每个 class 文件都要按照一定的次序排放，类名，访问权限，成员变量，成员方法等(具体可回顾<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-4-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6/">分析class文件</a>)。如何描述类名，成员变量，成员方法？就是在 class 文件中对应的位置保存一个整数，用来指向 class 文件中另一块区域——常量池中的一个常量(字符串)，用字符串来描述这是什么。<br>在强调一遍：class 文件是在本地磁盘上的文件，其内部是死的。</p>
<p>那么接下来将 class 文件读到内存中，其常量池也要进行相应的转换。如果是基本类型的常量那么原封不动，但如果表示的是一个类的引用，在 class 文件中使用的还是字符串，用来说明是哪个类，而在运行期间，就要真正的加载这个类(保存在方法区)，然后指向加载的这个类，而不是之前简单的字符串了。</p>
<p>到这里，应该对两个常量池的作用有一个清楚的了解，自己之前就是把两个常量池当成一个，直接拿来用了！所以在描述常量池时，我会用 <code>class 文件中的常量池</code> 和 <code>运行时常量池</code> 来做区分。</p>
<p>所以，相对于 class 文件中的常量池，运行时常量池是在内存中的，是活的。由 class 文件中的常量池向运行时常量池的转换如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要作用是将class文件中的常量池转换为运行时常量池;</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RuntimeConstantPool</span><span class="params">(Zclass clazz, ConstantPool classFileConstantPool)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">    ConstantInfo[] classFileConstantInfos = classFileConstantPool.getInfos();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> classFileConstantInfos.length;</span><br><span class="line">    <span class="built_in">this</span>.infos = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">ConstantInfo</span> <span class="variable">classFileConstantInfo</span> <span class="operator">=</span> classFileConstantInfos[i];</span><br><span class="line">        <span class="keyword">switch</span> (classFileConstantInfo.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Integer:</span><br><span class="line">                <span class="type">ConstantIntegerInfo</span> <span class="variable">intInfo</span> <span class="operator">=</span> (ConstantIntegerInfo) classFileConstantInfo;</span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;Integer&gt;(intInfo.getVal(), ConstantInfo.CONSTANT_Integer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Float:</span><br><span class="line">                <span class="type">ConstantFloatInfo</span> <span class="variable">floatInfo</span> <span class="operator">=</span> (ConstantFloatInfo) classFileConstantInfo;</span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;Float&gt;(floatInfo.getVal(), ConstantInfo.CONSTANT_Float);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Long:</span><br><span class="line">                <span class="comment">//Long 和 Double 在转换结束之后，都要进行 i++,以适配 class 文件中常量池的索引</span></span><br><span class="line">                <span class="type">ConstantLongInfo</span> <span class="variable">longInfo</span> <span class="operator">=</span> (ConstantLongInfo) classFileConstantInfo;</span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;Long&gt;(longInfo.getVal(), ConstantInfo.CONSTANT_Long);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Double:</span><br><span class="line">                <span class="type">ConstantDoubleInfo</span> <span class="variable">doubleInfo</span> <span class="operator">=</span> (ConstantDoubleInfo) classFileConstantInfo;</span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;Double&gt;(doubleInfo.getVal(), ConstantInfo.CONSTANT_Double);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_String:</span><br><span class="line">                <span class="comment">//在对字符串引用进行转换的时候，转为字符串直接引用</span></span><br><span class="line">                <span class="type">ConstantStringInfo</span> <span class="variable">stringInfo</span> <span class="operator">=</span> (ConstantStringInfo) classFileConstantInfo;</span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;String&gt;(stringInfo.getString(), ConstantInfo.CONSTANT_String);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Class:</span><br><span class="line">                <span class="type">ConstantClassInfo</span> <span class="variable">classInfo</span> <span class="operator">=</span> (ConstantClassInfo) classFileConstantInfo;</span><br><span class="line">                <span class="comment">//ref 类中真正需要的是 传入上面的 clazz</span></span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;ClassRef&gt;(<span class="keyword">new</span> <span class="title class_">ClassRef</span>(<span class="built_in">this</span>, classInfo), ConstantInfo.CONSTANT_Class);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Fieldref:</span><br><span class="line">                <span class="type">ConstantFieldRefInfo</span> <span class="variable">fieldRefInfo</span> <span class="operator">=</span> (ConstantFieldRefInfo) classFileConstantInfo;</span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;FieldRef&gt;(<span class="keyword">new</span> <span class="title class_">FieldRef</span>(<span class="built_in">this</span>, fieldRefInfo), ConstantInfo.CONSTANT_Fieldref);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Methodref:</span><br><span class="line">                <span class="type">ConstantMethodRefInfo</span> <span class="variable">methodRefInfo</span> <span class="operator">=</span> (ConstantMethodRefInfo) classFileConstantInfo;</span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;MethodRef&gt;(<span class="keyword">new</span> <span class="title class_">MethodRef</span>(<span class="built_in">this</span>, methodRefInfo), ConstantInfo.CONSTANT_Methodref);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_InterfaceMethodref:</span><br><span class="line">                <span class="type">ConstantInterfaceMethodRefInfo</span> <span class="variable">interfaceMethodRefInfo</span> <span class="operator">=</span> (ConstantInterfaceMethodRefInfo) classFileConstantInfo;</span><br><span class="line">                <span class="built_in">this</span>.infos[i] = <span class="keyword">new</span> <span class="title class_">RuntimeConstantInfo</span>&lt;InterfaceMethodRef&gt;(<span class="keyword">new</span> <span class="title class_">InterfaceMethodRef</span>(<span class="built_in">this</span>, interfaceMethodRefInfo), ConstantInfo.CONSTANT_InterfaceMethodref);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">//还有一些jdk1.7才开始支持的动态属性,不在本虚拟机的实现范围内</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是对以下四种常量进行转换：</p>
<ul>
<li>类符号引用</li>
<li>字段符号引用</li>
<li>方法符号引用</li>
<li>接口方法符号引用</li>
</ul>
<p>这里再区分一个概念，拿字段符号引用来说，什么是字段符号引用，和上面讲到的方法区中要转换的字段又有什么关系？<br>以下面一个简单的例子说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中 str 就是之前方法区要转换的字段。System.out 是字段符号引用,因为该 out 字段并非类 A 中定义的，而是在 System 类中定义的。</p>
<p>二者相同点：都是字段，那么是字段就要有字段名，类型，所在的类</p>
<p>不同的是：<br>方法区要转换的字段，是在当前类声明的成员变量，所以其所在的类就是当前类。<br>字段引用：FieldRef 类没有直接的一个字段指向其所在的类，而是有一个所在类的名字，那么在使用字段引用(FieldRef)时这就需要以下两步解决：</p>
<ul>
<li>用类加载器根据类名将对应的类加载进来</li>
<li>在从上一步加载到的类中，查找其定义的对应的字段，从而获取到真正的字段</li>
</ul>
<p>是在方法中的 code 属性中用到的。f 方法对应的字节码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 getstatic #2 &lt;java/lang/System.out&gt;</span><br><span class="line">3 invokevirtual #3 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">6 return</span><br></pre></td></tr></table></figure>
<p>其中的 getstatic 指令，后跟的索引2，指向的就是运行时常量池中的一个字段引用。那么 getstatic 指令要做的是从运行时常量池获取到一个 FieldRef，然后根据其类名加载类——System，因为 out 是类 System 中定义的一个变量，所以从 System 的 filed[] 数组中根据字段名找到对应的字段 field，<br>最后将该 field 压入操作数栈。</p>
<p>在上面的 invokevirtual 指令中，其后跟的索引3指向的是运行时常量池中的一个方法引用(MethodRef)，其方法名为println，该方法在 java&#x2F;io&#x2F;PrintStream 中定义，也就是 System.out 的类型。和字段引用解析类似，也是先加载其所在的类java&#x2F;io&#x2F;PrintStream到方法区，然后根据方法名找到对应的方法，最重要的是拿到方法中的 code 字节码，从而进行该方法的调用！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一节主要介绍了线程共享的运行时数据区，该数据区包含两个重要的概念：方法区和运行时常量池。同时还着重强调了两组概念：</p>
<ul>
<li>class 文件中的常量池 和 运行时常量池</li>
<li>类中定义的字段、方法 和 字段引用，方法引用</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>本文作者:</span>
                        <span>Zachaxy</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>版权声明:</span>
                        <span>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JVM/"># JVM</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/01/04/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-12-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">手写JVM系列(12)-类加载器的实现</a>
            
            
            <a class="next" rel="next" href="/2017/12/13/Groovy%E4%B8%8EDSL/">Groovy与DSL</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zachaxy | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>