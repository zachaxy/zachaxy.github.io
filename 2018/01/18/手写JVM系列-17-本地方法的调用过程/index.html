<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zachaxy">





<title>手写JVM系列(17)本地方法的调用过程 | Hexo</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Zachaxy&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Zachaxy&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">手写JVM系列(17)本地方法的调用过程</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zachaxy&nbsp;&#124;&nbsp;</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 18, 2018&nbsp;&nbsp;22:26:52&nbsp;&#124;&nbsp;</a>
                        </span>
                    

                    
                        <span class="post-count">
                        Words: <a href="#">9.8k&nbsp;&#124;&nbsp;</a>
                        </span>
                    

                    
                        <span class="post-readtime">
                        About: <a href="#">9 mins.</a>
                        </span>
                    

                    
                </div>
            
        </header>

        <div class="post-content">
            <p>java 中有一些方法前面的关键字是<code>native</code>，该关键字修饰的方法表明当前方法不是由 java 实现的方法，而是由本地语言编写的。本地语言就是所在的操作系统所用的语言。因为一些和操作系统底层相关的方法是 java 无法实现的，或者基于性能的考虑，由 java 实现并没有用本地方法实现在执行效率上更高效，所以会用到本地方法。</p>
<p>本地方法的调用是通过 JNI(Java Native Interface)来实现的，JNI 是 JVM 中的一个重要组成部分，但是要让 JVM 支持 JNI 规范还需要做大量的工作，而本系列关于 JVM 的介绍主要还是 JVM 的工作原理，为了不陷入到 JNI 的细节中，同时我们的 JVM 是用 java 来实现的，本身也不具备实现 JNI 规范的能力。因此这里只是通过简单的实例，通过 java 来描述 JNI 的实现过程。本节所实现的代码都在<a target="_blank" rel="noopener" href="https://github.com/zachaxy/JVM/tree/master/Java/src/znative">znative 包下</a><br>有关 JNI 的细节，请参考<a href="https://zachaxy.github.io/tags/JNI/">JNI 系列文章</a></p>
<span id="more"></span>

<h1 id="本地方法的注册"><a href="#本地方法的注册" class="headerlink" title="本地方法的注册"></a>本地方法的注册</h1><p>这里提到了注册，一般说起注册，都是在某处进行登记，表明自身的存在。其实在 JVM 中有一个<strong>本地方法注册表</strong>，native 方法的注册也是起一个标记占坑的作用，在本地方法表中注册本地方法，方便后面 JVM 需要调用本地方法时，能够从本地方法注册表中找到对应的本地方法。本节注册本地方法的代码请参考<a target="_blank" rel="noopener" href="https://github.com/zachaxy/JVM/tree/master/Java/src/znative/RegisterCenter.java">RegisterCenter.java</a></p>
<p>JVM 一般是用 c 语言编写的，在 JVM 的实现中，本地方法其实是在 JVM 中实现的， java 中本地方法都会映射为 JVM 中 c 的一个方法指针。</p>
<p>要实现本地方法的注册，其实就是实现<strong>本地方法注册表</strong>，本地方法注册表本质是上就是一个 map 的数据结构，其 key 为方法所在的类+方法名+方法签名，value 为本地方法的指针。<br>然而我们用 java 实现的 JVM ，所以只能用接口的方式来模拟 c 中的方法指针。<strong>再次强调用 java 来实现 JVM 是不正规的，但是通过本章的介绍，依然可以对 JVM 本地方法的实现有一个整理的理解。</strong><br>用接口的方式模拟 c 中的指针，我们所定义的接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NativeMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Zframe frame)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 NativeMethod 接口，其接口中只有一个 run 方法，用来执行本地方法，同时该方法需要一个 frame 参数，之前介绍 Frame 时，代表一个方法的工作空间，同样本地方法也需要一个工作空间，该 frame 参数就是当前本地方法的工作空间。</p>
<p>下面是本地方法的注册实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, NativeMethod&gt; nativeMethods = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String className, String methodName, String methodDescriptor, NativeMethod nativeMethod)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> className + <span class="string">&quot;~&quot;</span> + methodName + <span class="string">&quot;~&quot;</span> + methodDescriptor;</span><br><span class="line">    nativeMethods.put(key, nativeMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="本地方法注册的时机"><a href="#本地方法注册的时机" class="headerlink" title="本地方法注册的时机"></a>本地方法注册的时机</h1><p>接下来要考虑的问题在何时进行注册，哪些方法需要注册。其实很多 java 类中都包含 native 方法，而在这些包含 native 方法的类中，一般都有一个 registerNatives 的本地方法，该方法的作用是用来将本类中其它的 native 方法注册到本地方法注册表中。而 registerNatives 方法都是在类的静态代码块中执行的，也就是当前类加载到虚拟机的时候，就将该类的本地方法注册到本地方法注册表中。<br>例如 <code>java.lang.Object</code>中的实现，java 中其它类基本上也是这样的套路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的 JVM 只是简易的实现版本，所有的方法都是通过代码手动注册的，所以并没有实现 registerNatives 方法，而是将 Object 中的 native 方法一一手动注册进来。当然可以在遇到 registerNatives 的本地方法时，就将扫描当前类中的 native 方法，依次注册进来。我们的 JVM 就不这样实现了，开篇也也说了我们不想花太多精力在 JNI 的实现细节上，所以我们只是会手动注册有限的几个本地方法，来大致了解一下本地方法调用的整个流程。所以如果遇到了调用 registerNatives 方法的情况，不管其所在的哪个类，就返回一个空的实现。</p>
<p>而我们的 JVM 中所手动注册有限的几个本地方法，都在 RegisterCenter 的 init 方法中手动注册，并在我们的 JVM 开启时，手动调用该方法，即完成了注册。已下就是我的 JVM 中所有实现的本地方法，如果各位感兴趣，可以继续向 init 方法中添加对应的注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对外供 JVM 启动后的唯一接入口，JVM 启动后应该立即调用 RegisterCenter 的 init 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    register(<span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;getClass&quot;</span>, <span class="string">&quot;()Ljava/lang/Class;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Nobject</span>.getClass());</span><br><span class="line">    register(<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getPrimitiveClass&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Nclass</span>.getPrimitiveClass());</span><br><span class="line">    register(<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getName0&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Nclass</span>.getName0());</span><br><span class="line">    register(<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;desiredAssertionStatus0&quot;</span>, <span class="string">&quot;(Ljava/lang/Class;)Z&quot;</span>, <span class="keyword">new</span> <span class="title class_">Nclass</span>.desiredAssertionStatus0());</span><br><span class="line">    register(<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;isArray&quot;</span>, <span class="string">&quot;()Z&quot;</span>, <span class="keyword">new</span> <span class="title class_">Nclass</span>.isArray());</span><br><span class="line">    register(<span class="string">&quot;java/lang/Throwable&quot;</span>, <span class="string">&quot;fillInStackTrace&quot;</span>, <span class="string">&quot;(I)Ljava/lang/Throwable;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Nthrowable</span>.fillInStackTrace());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="为本地方法注入字节码"><a href="#为本地方法注入字节码" class="headerlink" title="为本地方法注入字节码"></a>为本地方法注入字节码</h1><p>上面只是完成了本地方法的注册，接下来就要实现本地方法的执行过程了。但是在实现本地方法之前，我们还要对本地方法进行特殊的处理，因为在 JVM 中并没有规定如何实现和调用本地方法。在 JVM 中调用 native 方法和调用其它方法所用的指令是一样的，也就是说调用本地静态方法会产生一个<code>invoke_static</code>的指令，调用本地非静态方法，会产生一个<code>invoke_special</code>的指令。但是我们对于本地方法，我们要做特殊的处理，因为 <strong>native 方法在 class 文件中没有字节码。</strong> </p>
<p>以静态普通方法和静态本地方法的指令为例，JVM 都是产生的 invoke_static 的指令，其指令的指令过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">INVOKE_STATIC</span> <span class="keyword">extends</span> <span class="title class_">Index16Instruction</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Zframe frame)</span> &#123;</span><br><span class="line">        <span class="type">RuntimeConstantPool</span> <span class="variable">runtimeConstantPool</span> <span class="operator">=</span> frame.getMethod().getClazz().getRuntimeConstantPool();</span><br><span class="line">        <span class="comment">//通过 index,拿到方法符号引用</span></span><br><span class="line">        <span class="type">MethodRef</span> <span class="variable">methodRef</span> <span class="operator">=</span> (MethodRef) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line">        <span class="type">Zmethod</span> <span class="variable">resolvedMethod</span> <span class="operator">=</span> methodRef.resolvedMethod();</span><br><span class="line">        <span class="keyword">if</span> (!resolvedMethod.isStatic()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompatibleClassChangeError</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Zclass</span> <span class="variable">clazz</span> <span class="operator">=</span> resolvedMethod.getClazz();</span><br><span class="line">        <span class="comment">//判断其 Class 是否已经加载过,如果还未加载,那么调用其类的&lt;clinit&gt;方法压栈</span></span><br><span class="line">        <span class="keyword">if</span> (!clazz.isInitStarted()) &#123;</span><br><span class="line">            <span class="comment">//当前指令已经是在执行 new 了,但是类还没有加载,所以当前帧先回退,让类初始化的帧入栈,等类初始化完成后,重新执行 new;</span></span><br><span class="line">            frame.revertNextPC();</span><br><span class="line">            ClassInitLogic.initClass(frame.getThread(), clazz);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MethodInvokeLogic.invokeMethod(frame, resolvedMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInvokeLogic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeMethod</span><span class="params">(Zframe invokerFrame, Zmethod method)</span> &#123;</span><br><span class="line">        <span class="type">Zthread</span> <span class="variable">thread</span> <span class="operator">=</span> invokerFrame.getThread();</span><br><span class="line">        <span class="type">Zframe</span> <span class="variable">newFrame</span> <span class="operator">=</span> thread.createFrame(method);</span><br><span class="line">        thread.pushFrame(newFrame);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">argSlotCount</span> <span class="operator">=</span> method.getArgSlotCount();</span><br><span class="line">        <span class="keyword">if</span> (argSlotCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> argSlotCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">Slot</span> <span class="variable">slot</span> <span class="operator">=</span> invokerFrame.getOperandStack().popSlot();</span><br><span class="line">                newFrame.getLocalVars().setSlot(i, slot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 invoke_static 指令中，解析方法符号引用为直接引用，然后就会调用<code>MethodInvokeLogic.invokeMethod(frame, resolvedMethod)</code>方法，该方法内部会创建一个新的 frame 来供被调用的方法来执行，此时 JVM 的栈帧的顶部就是该 frame，解释器此时会读取 JVM 栈帧顶部的 frame 作为当前 frame，并执行该 frame 所绑定的 method 中的字节码。因为本地方法没有字节码，但我们又要让本地方法也适应 JVM 解释器，因此我们的做法是为本地方法注入字节码，本地方法的字节码只需要两个字节，第一个字节用来表示接下来要执行的方法是本地方法，(JVM 规范中预留了两条指令，操作码为 0xFE 和 0xFF，这里我们使用 0xFE 来表示本地方法的调用)。第二个字节用来表示本地方法的 return 指令，其 return 指令和非 native 方法的 return 指令完全一样。</p>
<p>接下来先完成本地方法字节码的构造，在创建 Zmethod 实例时，如果该方法是 native 的，我们将进行如下构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Zmethod</span><span class="params">(Zclass clazz, MemberInfo classFileMethod)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(clazz, classFileMethod);</span><br><span class="line">    copyAttributes(classFileMethod);</span><br><span class="line">    parsedDescriptor = <span class="keyword">new</span> <span class="title class_">MethodDescriptor</span>(<span class="built_in">this</span>.descriptor);</span><br><span class="line">    argSlotCount = calcArgSlotCount(parsedDescriptor.getParameterTypes());</span><br><span class="line">    <span class="keyword">if</span> (isNative()) &#123;</span><br><span class="line">        injectCodeAttribute(parsedDescriptor.getReturnType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM 并没有规定如何实现和调用本地方法，这里我们依然使用 JVM 栈 来执行本地方法</span></span><br><span class="line"><span class="comment">// 但是本地方法中并不包含字节码，那么本地方法的调用，这里我们利用接口来实现调用对应的方法；</span></span><br><span class="line"><span class="comment">// 同时 JVM 中预留了两条指令，操作码分别是 0xff 和 0xfe，下面使用 0xfe 来当前方法为表示本地方法</span></span><br><span class="line"><span class="comment">// 第二个字节为本地方法的返回指令，该指令和普通方法的返回指令是一样的。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">injectCodeAttribute</span><span class="params">(String returnType)</span> &#123;</span><br><span class="line">    <span class="comment">//本地方法的操作数栈暂时为 4;至少能容纳返回值</span></span><br><span class="line">    <span class="built_in">this</span>.maxStack = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//本地方法的局部变量表只用来存放参数,因此直接这样赋值</span></span><br><span class="line">    <span class="built_in">this</span>.maxLocals = <span class="built_in">this</span>.argSlotCount;</span><br><span class="line">    <span class="comment">//接下来为本地方法构造字节码:起始第一个字节都是 0xfe,用来表用这是本地方法;</span></span><br><span class="line">    <span class="comment">//第二个字节码则根据不同的返回值类型选择相应的 xreturn 的指令即可</span></span><br><span class="line">    <span class="comment">//不必担心下面的 byte 的强转，因为在读取字节码时，使用的是 readUint8()方法</span></span><br><span class="line">    <span class="keyword">switch</span> (returnType.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.code = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;(<span class="type">byte</span>) <span class="number">0xfe</span>, (<span class="type">byte</span>) <span class="number">0xb1</span>&#125;; <span class="comment">// return</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.code = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;(<span class="type">byte</span>) <span class="number">0xfe</span>, (<span class="type">byte</span>) <span class="number">0xb0</span>&#125;; <span class="comment">// areturn</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.code = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;(<span class="type">byte</span>) <span class="number">0xfe</span>, (<span class="type">byte</span>) <span class="number">0xaf</span>&#125;; <span class="comment">// dreturn</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.code = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;(<span class="type">byte</span>) <span class="number">0xfe</span>, (<span class="type">byte</span>) <span class="number">0xae</span>&#125;; <span class="comment">// freturn</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.code = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;(<span class="type">byte</span>) <span class="number">0xfe</span>, (<span class="type">byte</span>) <span class="number">0xad</span>&#125;; <span class="comment">// lreturn</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">this</span>.code = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;(<span class="type">byte</span>) <span class="number">0xfe</span>, (<span class="type">byte</span>) <span class="number">0xac</span>&#125;;<span class="comment">// ireturn</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在上面的字节注入中，还未本地方法添加了本地变量表和操作数栈。本地变量表的大小为本地方法的参数个数。操作数栈的大小这里设置为 4，其实这个值至少是 2，因为我们只是用操作数栈来盛放本地方法的返回值。</p>
<h1 id="本地方法的调用"><a href="#本地方法的调用" class="headerlink" title="本地方法的调用"></a>本地方法的调用</h1><p>在完成了本地方法的字节注入之后，终于可以实现本地方法的调用了。因为我们为本地方法注入了两个字节码，所以在 JVM 的解释器真正执行本地方法时，会本地方法中的这两个字节码，首先是 0xFE，这是我们自己构造的，解释器在遇到这个字节码时，其实是不认识的，因为 JVM 规范中没有用到该字节码，于是在这里我们手动创建一个 invoke_native 指令，该指令就对应 0xFE。不要忘了在我们的 InstructionFactory.java 的 createInstruction 方法中，添加对该字节码的解析。注意：JVM 中是没有 invoke_native 指令的，这是我们自己创建的指令。其具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">INVOKE_NATIVE</span> <span class="keyword">extends</span> <span class="title class_">NoOperandsInstruction</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Zframe frame)</span> &#123;</span><br><span class="line">        <span class="type">Zmethod</span> <span class="variable">method</span> <span class="operator">=</span> frame.getMethod();</span><br><span class="line">        <span class="type">String</span> <span class="variable">clazzName</span> <span class="operator">=</span> method.getClazz().thisClassName;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> method.getDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="type">NativeMethod</span> <span class="variable">nativeMethod</span> <span class="operator">=</span> RegisterCenter.findNativeMethod(clazzName, methodName, descriptor);</span><br><span class="line">        <span class="keyword">if</span> (nativeMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodInfo</span> <span class="operator">=</span> clazzName + <span class="string">&quot;.&quot;</span> + methodName + descriptor;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(methodInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativeMethod.run(frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面也说了本地方法中没有字节码，我们认为注入了标示本地方法开始的字节码 0xFE，已经本地方法返回的字节码。但是中间具体的指令流程我们是无法用字节码构造了，因为这样太麻烦了。所以在 java 层面是不知道本地方法内部如何执行，因为本地方法会映射到 JVM 中的一个 c 的指针，也就是说每一个本地方法对应的具体实现都已经在 JVM 中实现好了，由该指针指向的代码来执行具体的逻辑(我们的 JVM 中就是通过接口来模拟方法指针了)。这就需要在 JVM 找到对应的本地方法的具体实现，并执行本地方法。</p>
<p>本地方法的查找，也很简单，只要从本地方法注册表中根据方法名获取到具体实现即可，我们这里是获取到 NativeMethod 接口的一个实现类，然后调用其 run 方法。这里要注意的是如果方法名为 registerNatives,则返回一个空实现即可，原因在文章开始已经解释过了。对于其它情况，如果在本地方法表中没有提前注册，那么将抛出 UnsatisfiedLinkError 的错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NativeMethod <span class="title function_">findNativeMethod</span><span class="params">(String className, String methodName, String methodDescriptor)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> className + <span class="string">&quot;~&quot;</span> + methodName + <span class="string">&quot;~&quot;</span> + methodDescriptor;</span><br><span class="line">    <span class="keyword">if</span> (nativeMethods.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nativeMethods.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;()V&quot;</span>.equals(methodDescriptor)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;registerNatives&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="comment">//返回一个空的方法执行体 emptyNativeMethod</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NativeMethod</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Zframe frame)</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="本地方法调用实战"><a href="#本地方法调用实战" class="headerlink" title="本地方法调用实战"></a>本地方法调用实战</h1><p>通过上面的讲解，可能还是一头雾水，请不要怀疑自己的能力，是我表达的不太够准确，因此在最后一节，准备了一个本地方法调用的实战，当你看明白了这个实战的流程之后，再看上面的讲解，也许你会豁然开朗。</p>
<p>本实战准备的例子是<a target="_blank" rel="noopener" href="https://github.com/zachaxy/JVM/blob/master/Java/src/test/TestGetClass11.java">TestGetClass11.java</a><br>测试所用的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="type">int</span>.class.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是调用了基本类型的类，<a href="https://zachaxy.github.io/2018/01/18/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-16-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/">上一章</a>反射中已经介绍了其实现原理，我们这里重点看 getName 方法，该方法内步流程是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.name;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>.name = name = getName0();</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title function_">getName0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>发现这里调用了 getName0 方法，而 getName0 方法就是本地方法。所以我们要在 JVM 中实现该方法。在 znative 包下，创建 Nclass.java，在 java&#x2F;lang&#x2F;Class 中的本地方法都将在 Nclass 中进行实现。不过我们并不打算将 Class 中的本地方法全部实现，这里只用到了 getName0 的方法，所以我们只实现 getName0 的逻辑，其具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">getName0</span> <span class="keyword">implements</span> <span class="title class_">NativeMethod</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Zframe frame)</span> &#123;</span><br><span class="line">        <span class="type">Zobject</span> <span class="variable">self</span> <span class="operator">=</span> frame.getLocalVars().getRef(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Zclass</span> <span class="variable">clazz</span> <span class="operator">=</span> (Zclass) self.extra;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getJavaName();</span><br><span class="line">        <span class="type">Zobject</span> <span class="variable">nameObj</span> <span class="operator">=</span> StringPool.jString(clazz.getLoader(), name);</span><br><span class="line">        frame.getOperandStack().pushRef(nameObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 JVM 本地方法 getName0 实现了 NativeMethod 接口，在 run 方法中，首先获取本地变量表中的第一个变量，也就是调用 getName0 方法的对象 <code>this</code>，然后获取到 this 的类，最核心就是 <code>class.getJavaName()</code>这一句，获取到当前 class 的 javaName，其实现也非常简单，在 Zclass.java 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getJavaName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> thisClassName.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了本地方法的具体实现，接下来记得在本地方法注册表中进行注册，其在 RegisterCenter.java 的 init 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	register(<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getName0&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Nclass</span>.getName0());</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后不要忘记在 JVM 启动之前，调用<code>RegisterCenter.init()</code>，将本地方法注册到 JVM 中。具体实现流程请参考<a target="_blank" rel="noopener" href="https://github.com/zachaxy/JVM/blob/master/Java/src/test/TestGetClass11.java">TestGetClass11.java</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>本文作者:</span>
                        <span>Zachaxy</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>版权声明:</span>
                        <span>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JVM/"># JVM</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/01/20/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-18-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">手写JVM系列(18)异常处理机制</a>
            
            
            <a class="next" rel="next" href="/2018/01/18/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-16-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/">手写JVM系列(16)反射机制简介</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zachaxy | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>